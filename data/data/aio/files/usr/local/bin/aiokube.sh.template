#!/usr/bin/env bash
set -euoE pipefail ## -E option will cause functions to inherit trap

. /usr/local/bin/release-image.sh

mkdir --parents /etc/kubernetes/{manifests,bootstrap-configs,bootstrap-manifests}

ETCD_ENDPOINTS=

bootkube_podman_run() {
    # we run all commands in the host-network to prevent IP conflicts with
    # end-user infrastructure.
    podman run --quiet --net=host "${@}"
}

MACHINE_CONFIG_ETCD_IMAGE=$(image_for etcd)

CLUSTER_ETCD_OPERATOR_IMAGE=$(image_for cluster-etcd-operator)
CONFIG_OPERATOR_IMAGE=$(image_for cluster-config-operator)

CLUSTER_BOOTSTRAP_IMAGE=$(image_for cluster-bootstrap)

KUBE_APISERVER_OPERATOR_IMAGE=$(image_for cluster-kube-apiserver-operator)
KUBE_CONTROLLER_MANAGER_OPERATOR_IMAGE=$(image_for cluster-kube-controller-manager-operator)
KUBE_SCHEDULER_OPERATOR_IMAGE=$(image_for cluster-kube-scheduler-operator)

OPENSHIFT_HYPERKUBE_IMAGE=$(image_for hyperkube)
OPENSHIFT_CLUSTER_POLICY_IMAGE=$(image_for cluster-policy-controller)


echo "Restarting cri-o to start wih latest modified configuration"
systemctl restart cri-o

mkdir --parents ./{bootstrap-manifests,manifests}

if [ ! -f kubeconfig.done ]
then
	echo "Updating kubeconfig..."
    cp auth/kubeconfig-loopback /etc/kubernetes/kubeconfig
	touch kubeconfig.done
fi



ETCD_ENDPOINTS=https://localhost:2379
if [ ! -f etcd-bootstrap.done ]
then
	echo "Rendering CEO Manifests..."
	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${CLUSTER_ETCD_OPERATOR_IMAGE}" \
		/usr/bin/cluster-etcd-operator render \
		--etcd-ca=/assets/tls/etcd-ca-bundle.crt \
		--etcd-ca-key=/assets/tls/etcd-signer.key \
		--manifest-etcd-image="${MACHINE_CONFIG_ETCD_IMAGE}" \
		--manifest-cluster-etcd-operator-image="${CLUSTER_ETCD_OPERATOR_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/etcd-bootstrap \
		--config-output-file=/assets/etcd-bootstrap/config \
		--cluster-config-file=/assets/manifests/cluster-network-02-config.yml

    sed -i 's/etcd-bootstrap-member/etcd-member/g' etcd-bootstrap/bootstrap-manifests/etcd-member-pod.yaml
    sed -i 's/openshift-etcd/kube-system/g' etcd-bootstrap/bootstrap-manifests/etcd-member-pod.yaml
	cp etcd-bootstrap/bootstrap-manifests/etcd-member-pod.yaml /etc/kubernetes/manifests/

	mkdir --parents /etc/kubernetes/static-pod-resources/etcd-member
	cp tls/etcd-ca-bundle.crt /etc/kubernetes/static-pod-resources/etcd-member/ca.crt
	cp --recursive etcd-bootstrap/bootstrap-manifests/secrets/etcd-all-serving /etc/kubernetes/static-pod-resources/etcd-member
	cp --recursive etcd-bootstrap/bootstrap-manifests/secrets/etcd-all-peer /etc/kubernetes/static-pod-resources/etcd-member

	touch etcd-bootstrap.done
fi

if [ ! -f config-bootstrap.done ]
then
	echo "Rendering cluster config manifests..."

	rm --recursive --force config-bootstrap

	ADDITIONAL_FLAGS=""
	if [ -f "$PWD/manifests/cloud-provider-config.yaml" ]; then
		ADDITIONAL_FLAGS="--cloud-provider-config-input-file=/assets/manifests/cloud-provider-config.yaml"
	fi

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${CONFIG_OPERATOR_IMAGE}" \
		/usr/bin/cluster-config-operator render \
		--cluster-infrastructure-input-file=/assets/manifests/cluster-infrastructure-02-config.yml \
		--cloud-provider-config-output-file=/assets/config-bootstrap/cloud-provider-config-generated.yaml \
		--config-output-file=/assets/config-bootstrap/config \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/config-bootstrap \
		${ADDITIONAL_FLAGS}

	cp config-bootstrap/manifests/* manifests/

	touch config-bootstrap.done
fi

if [ ! -f kube-apiserver-bootstrap.done ]
then
	echo "Rendering Kubernetes API server core manifests..."

	rm --recursive --force kube-apiserver-bootstrap

	bootkube_podman_run  \
		--volume "$PWD:/assets:z" \
		"${KUBE_APISERVER_OPERATOR_IMAGE}" \
		/usr/bin/cluster-kube-apiserver-operator render \
		--manifest-etcd-serving-ca=etcd-ca-bundle.crt \
		--manifest-etcd-server-urls="${ETCD_ENDPOINTS}" \
		--manifest-image="${OPENSHIFT_HYPERKUBE_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/kube-apiserver-bootstrap \
		--config-output-file=/assets/kube-apiserver-bootstrap/config \
		--cluster-config-file=/assets/manifests/cluster-network-02-config.yml \
		--cluster-auth-file=/assets/manifests/cluster-authentication-02-config.yaml

	cp kube-apiserver-bootstrap/config /etc/kubernetes/bootstrap-configs/kube-apiserver-config.yaml
	cp kube-apiserver-bootstrap/bootstrap-manifests/* bootstrap-manifests/
	cp kube-apiserver-bootstrap/manifests/* manifests/
    sed -i 's/bootstrap-kube-apiserver/kube-apiserver/g' bootstrap-manifests/kube-apiserver-pod.yaml

	touch kube-apiserver-bootstrap.done
fi

if [ ! -f kube-controller-manager-bootstrap.done ]
then
	echo "Rendering Kubernetes Controller Manager core manifests..."

	rm --recursive --force kube-controller-manager-bootstrap

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${KUBE_CONTROLLER_MANAGER_OPERATOR_IMAGE}" \
		/usr/bin/cluster-kube-controller-manager-operator render \
		--cluster-policy-controller-image="${OPENSHIFT_CLUSTER_POLICY_IMAGE}" \
		--manifest-image="${OPENSHIFT_HYPERKUBE_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/kube-controller-manager-bootstrap \
		--config-output-file=/assets/kube-controller-manager-bootstrap/config \
		--cpc-config-output-file=/assets/kube-controller-manager-bootstrap/cpc-config \
		--cluster-config-file=/assets/manifests/cluster-network-02-config.yml

	cp kube-controller-manager-bootstrap/config /etc/kubernetes/bootstrap-configs/kube-controller-manager-config.yaml
	cp kube-controller-manager-bootstrap/cpc-config /etc/kubernetes/bootstrap-configs/cluster-policy-controller-config.yaml
	cp kube-controller-manager-bootstrap/bootstrap-manifests/* bootstrap-manifests/
    sed -i 's/bootstrap-kube-controller-manager/kube-controller-manager/g' bootstrap-manifests/kube-controller-manager-pod.yaml

	touch kube-controller-manager-bootstrap.done
fi

if [ ! -f kube-scheduler-bootstrap.done ]
then
	echo "Rendering Kubernetes Scheduler core manifests..."

	rm --recursive --force kube-scheduler-bootstrap

	bootkube_podman_run \
		--volume "$PWD:/assets:z" \
		"${KUBE_SCHEDULER_OPERATOR_IMAGE}" \
		/usr/bin/cluster-kube-scheduler-operator render \
		--manifest-image="${OPENSHIFT_HYPERKUBE_IMAGE}" \
		--asset-input-dir=/assets/tls \
		--asset-output-dir=/assets/kube-scheduler-bootstrap \
		--config-output-file=/assets/kube-scheduler-bootstrap/config

	cp kube-scheduler-bootstrap/config /etc/kubernetes/bootstrap-configs/kube-scheduler-config.yaml
	cp kube-scheduler-bootstrap/bootstrap-manifests/* bootstrap-manifests/
    sed -i 's/bootstrap-kube-scheduler/kube-scheduler/g' bootstrap-manifests/kube-scheduler-pod.yaml

	touch kube-scheduler-bootstrap.done
fi

# Wait for the etcd cluster to come up.
until bootkube_podman_run \
		--rm \
		--name etcdctl \
		--env ETCDCTL_API=3 \
		--volume /opt/openshift/tls:/opt/openshift/tls:ro,z \
		--entrypoint etcdctl \
		"${MACHINE_CONFIG_ETCD_IMAGE}" \
		--dial-timeout=10m \
		--cacert=/opt/openshift/tls/etcd-ca-bundle.crt \
		--cert=/opt/openshift/tls/etcd-client.crt \
		--key=/opt/openshift/tls/etcd-client.key \
		--endpoints="${ETCD_ENDPOINTS}" \
		endpoint health
do
	echo "etcdctl failed. Retrying in 5 seconds..."
	sleep 5
done

echo "etcd cluster up. Killing etcd certificate signer..."


if [ ! -f control-plane.done ]
then
    echo "Setting up control plane  ..."
    mkdir -p /etc/kubernetes/bootstrap-secrets/
    cp /opt/openshift/tls/* /etc/kubernetes/bootstrap-secrets/
    #Copy the admin kubeconfig - this is a hack!
    cp /opt/openshift/auth/kubeconfig /etc/kubernetes/bootstrap-secrets/
    cp /opt/openshift/bootstrap-manifests/* /etc/kubernetes/manifests/

	touch control-plane.done
fi

echo "Deploying CRDs needed by kube-apiserver"
until kubectl --kubeconfig=/opt/openshift/auth/kubeconfig-loopback apply -f /opt/openshift/config-bootstrap/manifests; do
    sleep 3s
done
echo "CRDs Deployed"

echo "Deploying DNS components"
until kubectl --kubeconfig=/opt/openshift/auth/kubeconfig-loopback apply -f /opt/openshift/manifests/dns; do
    sleep 1s
done
echo "DNS Deployed"

echo "Waiting for node to join"
until [ $(kubectl --kubeconfig=/opt/openshift/auth/kubeconfig-loopback get nodes | grep Ready | wc -l) -eq 1 ]; do
    sleep 5s
done
echo "Node joined"
echo -e "$(kubectl --kubeconfig=/opt/openshift/auth/kubeconfig-loopback get nodes)"

echo "Waiting for CSR approval"
until [ $(kubectl --kubeconfig=/opt/openshift/auth/kubeconfig-loopback get csr | grep Pending | wc -l) -eq 0 ]; do
    sleep 5s
done
echo "Stopping approve-csr service"
systemctl disable approve-csr.service
systemctl stop approve-csr.service


echo "Adding labels"
kubectl --kubeconfig /opt/openshift/auth/kubeconfig-loopback label node master1 node-role.kubernetes.io/worker=
kubectl --kubeconfig /opt/openshift/auth/kubeconfig-loopback label node master1 node-role.kubernetes.io/master=

echo "Enable kubelet service"
systemctl enable kubelet.service

systemctl disable aiokube.service
touch /opt/openshift/.aiokube.done
echo "aiokube.service complete"
